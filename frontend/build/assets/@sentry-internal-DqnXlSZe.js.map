{"version":3,"file":"@sentry-internal-DqnXlSZe.js","sources":["../../node_modules/@sentry-internal/browser-utils/build/esm/debug-build.js","../../node_modules/@sentry-internal/browser-utils/build/esm/types.js","../../node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js","../../node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js","../../node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js","../../node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js"],"sourcesContent":["/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\nexport { DEBUG_BUILD };\n//# sourceMappingURL=debug-build.js.map\n","import { GLOBAL_OBJ } from '@sentry/core';\n\nconst WINDOW = GLOBAL_OBJ\n\n;\n\nexport { WINDOW };\n//# sourceMappingURL=types.js.map\n","import { addHandler, maybeInstrument, triggerHandlers, fill, addNonEnumerableProperty, uuid4 } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\nconst DEBOUNCE_DURATION = 1000;\n\nlet debounceTimerID;\nlet lastCapturedEventType;\nlet lastCapturedEventTargetId;\n\n/**\n * Add an instrumentation handler for when a click or a keypress happens.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addClickKeypressInstrumentationHandler(handler) {\n  const type = 'dom';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentDOM);\n}\n\n/** Exported for tests only. */\nfunction instrumentDOM() {\n  if (!WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n    const globalObject = WINDOW ;\n    const proto = globalObject[target]?.prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto?.hasOwnProperty?.('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function ( type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const handlers = (this.__sentry_instrumentation_handlers__ =\n              this.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function ( type, listener, options) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const handlers = this.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete this.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\n/**\n * Check whether the event is similar to the last captured one. For example, two click events on the same button.\n */\nfunction isSimilarToLastCapturedEvent(event) {\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (event.type !== lastCapturedEventType) {\n    return false;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (!event.target || (event.target )._sentryId !== lastCapturedEventTargetId) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return true;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(eventType, target) {\n  // We are only interested in filtering `keypress` events for now.\n  if (eventType !== 'keypress') {\n    return false;\n  }\n\n  if (!target?.tagName) {\n    return true;\n  }\n\n  // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n  // e.g.tabbing through elements, hotkeys, etc.\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n */\nfunction makeDOMEventHandler(\n  handler,\n  globalListener = false,\n) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || event['_sentryCaptured']) {\n      return;\n    }\n\n    const target = getEventTarget(event);\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event.type, target)) {\n      return;\n    }\n\n    // Mark event as \"seen\"\n    addNonEnumerableProperty(event, '_sentryCaptured', true);\n\n    if (target && !target._sentryId) {\n      // Add UUID to event target so we can identify if\n      addNonEnumerableProperty(target, '_sentryId', uuid4());\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.\n    // If there is a last captured event, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    if (!isSimilarToLastCapturedEvent(event)) {\n      const handlerData = { event, name, global: globalListener };\n      handler(handlerData);\n      lastCapturedEventType = event.type;\n      lastCapturedEventTargetId = target ? target._sentryId : undefined;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      lastCapturedEventTargetId = undefined;\n      lastCapturedEventType = undefined;\n    }, DEBOUNCE_DURATION);\n  };\n}\n\nfunction getEventTarget(event) {\n  try {\n    return event.target ;\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n    return null;\n  }\n}\n\nexport { addClickKeypressInstrumentationHandler, instrumentDOM };\n//# sourceMappingURL=dom.js.map\n","import { addHandler, maybeInstrument, triggerHandlers, supportsHistory, fill } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\nlet lastHref;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addHistoryInstrumentationHandler(handler) {\n  const type = 'history';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentHistory);\n}\n\n/**\n * Exported just for testing\n */\nfunction instrumentHistory() {\n  // The `popstate` event may also be triggered on `pushState`, but it may not always reliably be emitted by the browser\n  // Which is why we also monkey-patch methods below, in addition to this\n  WINDOW.addEventListener('popstate', () => {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n\n    if (from === to) {\n      return;\n    }\n\n    const handlerData = { from, to } ;\n    triggerHandlers('history', handlerData);\n  });\n\n  // Just guard against this not being available, in weird environments\n  if (!supportsHistory()) {\n    return;\n  }\n\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function ( ...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        const from = lastHref;\n\n        // Ensure the URL is absolute\n        // this can be either a path, then it is relative to the current origin\n        // or a full URL of the current origin - other origins are not allowed\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#url\n        // coerce to string (this is what pushState does)\n        const to = getAbsoluteUrl(String(url));\n\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n\n        if (from === to) {\n          return originalHistoryFunction.apply(this, args);\n        }\n\n        const handlerData = { from, to } ;\n        triggerHandlers('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\nfunction getAbsoluteUrl(urlOrPath) {\n  try {\n    const url = new URL(urlOrPath, WINDOW.location.origin);\n    return url.toString();\n  } catch {\n    // fallback, just do nothing\n    return urlOrPath;\n  }\n}\n\nexport { addHistoryInstrumentationHandler, instrumentHistory };\n//# sourceMappingURL=history.js.map\n","import { isNativeFunction, logger } from '@sentry/core';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { WINDOW } from './types.js';\n\n/**\n * We generally want to use window.fetch / window.setTimeout.\n * However, in some cases this may be wrapped (e.g. by Zone.js for Angular),\n * so we try to get an unpatched version of this from a sandboxed iframe.\n */\n\nconst cachedImplementations = {};\n\n/**\n * Get the native implementation of a browser function.\n *\n * This can be used to ensure we get an unwrapped version of a function, in cases where a wrapped function can lead to problems.\n *\n * The following methods can be retrieved:\n * - `setTimeout`: This can be wrapped by e.g. Angular, causing change detection to be triggered.\n * - `fetch`: This can be wrapped by e.g. ad-blockers, causing an infinite loop when a request is blocked.\n */\nfunction getNativeImplementation(\n  name,\n) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n\n  let impl = WINDOW[name] ;\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFunction(impl)) {\n    return (cachedImplementations[name] = impl.bind(WINDOW) );\n  }\n\n  const document = WINDOW.document;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow?.[name]) {\n        impl = contentWindow[name] ;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      // Could not create sandbox iframe, just use window.xxx\n      DEBUG_BUILD && logger.warn(`Could not create sandbox iframe for ${name} check, bailing to window.${name}: `, e);\n    }\n  }\n\n  // Sanity check: This _should_ not happen, but if it does, we just skip caching...\n  // This can happen e.g. in tests where fetch may not be available in the env, or similar.\n  if (!impl) {\n    return impl;\n  }\n\n  return (cachedImplementations[name] = impl.bind(WINDOW) );\n}\n\n/** Clear a cached implementation. */\nfunction clearCachedImplementation(name) {\n  cachedImplementations[name] = undefined;\n}\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction fetch(...rest) {\n  return getNativeImplementation('fetch')(...rest);\n}\n\n/**\n * Get an unwrapped `setTimeout` method.\n * This ensures that even if e.g. Angular wraps `setTimeout`, we get the native implementation,\n * avoiding triggering change detection.\n */\nfunction setTimeout(...rest) {\n  return getNativeImplementation('setTimeout')(...rest);\n}\n\nexport { clearCachedImplementation, fetch, getNativeImplementation, setTimeout };\n//# sourceMappingURL=getNativeImplementation.js.map\n","import { addHandler, maybeInstrument, timestampInSeconds, isString, triggerHandlers } from '@sentry/core';\nimport { WINDOW } from '../types.js';\n\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addXhrInstrumentationHandler(handler) {\n  const type = 'xhr';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nfunction instrumentXHR() {\n  if (!(WINDOW ).XMLHttpRequest) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.open = new Proxy(xhrproto.open, {\n    apply(\n      originalOpen,\n      xhrOpenThisArg,\n      xhrOpenArgArray\n\n,\n    ) {\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n      //       it means the error, that was caused by your XHR call did not\n      //       have a stack trace. If you are using HttpClient integration,\n      //       this is the expected behavior, as we are using this virtual error to capture\n      //       the location of your XHR call, and group your HttpClient events accordingly.\n      const virtualError = new Error();\n\n      const startTimestamp = timestampInSeconds() * 1000;\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = isString(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : undefined;\n      const url = parseXhrUrlArg(xhrOpenArgArray[1]);\n\n      if (!method || !url) {\n        return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n      }\n\n      xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {},\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        xhrOpenThisArg.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (xhrOpenThisArg.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhrOpenThisArg.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          const handlerData = {\n            endTimestamp: timestampInSeconds() * 1000,\n            startTimestamp,\n            xhr: xhrOpenThisArg,\n            virtualError,\n          };\n          triggerHandlers('xhr', handlerData);\n        }\n      };\n\n      if ('onreadystatechange' in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === 'function') {\n        xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {\n          apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray) {\n            onreadystatechangeHandler();\n            return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);\n          },\n        });\n      } else {\n        xhrOpenThisArg.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {\n        apply(\n          originalSetRequestHeader,\n          setRequestHeaderThisArg,\n          setRequestHeaderArgArray,\n        ) {\n          const [header, value] = setRequestHeaderArgArray;\n\n          const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo && isString(header) && isString(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);\n        },\n      });\n\n      return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n    },\n  });\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.send = new Proxy(xhrproto.send, {\n    apply(originalSend, sendThisArg, sendArgArray) {\n      const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];\n\n      if (!sentryXhrData) {\n        return originalSend.apply(sendThisArg, sendArgArray);\n      }\n\n      if (sendArgArray[0] !== undefined) {\n        sentryXhrData.body = sendArgArray[0];\n      }\n\n      const handlerData = {\n        startTimestamp: timestampInSeconds() * 1000,\n        xhr: sendThisArg,\n      };\n      triggerHandlers('xhr', handlerData);\n\n      return originalSend.apply(sendThisArg, sendArgArray);\n    },\n  });\n}\n\n/**\n * Parses the URL argument of a XHR method to a string.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open#url\n * url: A string or any other object with a stringifier — including a URL object — that provides the URL of the resource to send the request to.\n *\n * @param url - The URL argument of an XHR method\n * @returns The parsed URL string or undefined if the URL is invalid\n */\nfunction parseXhrUrlArg(url) {\n  if (isString(url)) {\n    return url;\n  }\n\n  try {\n    // If the passed in argument is not a string, it should have a `toString` method as a stringifier.\n    // If that fails, we just return undefined (like in IE11 where URL is not available)\n    return (url ).toString();\n  } catch {} // eslint-disable-line no-empty\n\n  return undefined;\n}\n\nexport { SENTRY_XHR_DATA_KEY, addXhrInstrumentationHandler, instrumentXHR };\n//# sourceMappingURL=xhr.js.map\n"],"names":["DEBUG_BUILD","WINDOW","GLOBAL_OBJ","DEBOUNCE_DURATION","debounceTimerID","lastCapturedEventType","lastCapturedEventTargetId","addClickKeypressInstrumentationHandler","handler","type","addHandler","maybeInstrument","instrumentDOM","triggerDOMHandler","triggerHandlers","globalDOMEventHandler","makeDOMEventHandler","target","proto","fill","originalAddEventListener","listener","options","handlers","handlerForType","originalRemoveEventListener","isSimilarToLastCapturedEvent","event","shouldSkipDOMEvent","eventType","globalListener","getEventTarget","addNonEnumerableProperty","uuid4","name","lastHref","addHistoryInstrumentationHandler","instrumentHistory","to","from","supportsHistory","historyReplacementFunction","originalHistoryFunction","args","url","getAbsoluteUrl","urlOrPath","cachedImplementations","getNativeImplementation","cached","impl","isNativeFunction","document","sandbox","contentWindow","e","logger","clearCachedImplementation","SENTRY_XHR_DATA_KEY","addXhrInstrumentationHandler","instrumentXHR","xhrproto","originalOpen","xhrOpenThisArg","xhrOpenArgArray","virtualError","startTimestamp","timestampInSeconds","method","isString","parseXhrUrlArg","onreadystatechangeHandler","xhrInfo","handlerData","originalOnreadystatechange","onreadystatechangeThisArg","onreadystatechangeArgArray","originalSetRequestHeader","setRequestHeaderThisArg","setRequestHeaderArgArray","header","value","originalSend","sendThisArg","sendArgArray","sentryXhrData"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}