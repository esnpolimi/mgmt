name: Deploy to Production

on:
  push:
    branches:
      - main  # Si attiva quando pushhi su main (dopo merge da staging)

permissions:
  contents: write  # Necessario per push di tag e branches

jobs:
  create-release-tag:
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.tag_version.outputs.new_tag }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Necessario per leggere tutti i tag
    
    - name: Get latest tag and increment
      id: tag_version
      run: |
        # Prendi l'ultimo tag (es. v1.2.3)
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        # Estrai versione (rimuovi 'v')
        VERSION=${LATEST_TAG#v}
        
        # Split in MAJOR.MINOR.PATCH
        IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
        
        # Incrementa PATCH - MINOR - MAJOR
        PATCH=$((PATCH + 0))
        MINOR=$((MINOR + 1))
        MAJOR=$((MAJOR + 0))
        
        # Nuova versione
        NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
        echo "New tag: $NEW_TAG"
        echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
    
    - name: Create and push tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a ${{ steps.tag_version.outputs.new_tag }} -m "Release ${{ steps.tag_version.outputs.new_tag }}"
        git push origin ${{ steps.tag_version.outputs.new_tag }}

  deploy-backend:
    runs-on: ubuntu-latest
    needs: create-release-tag
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Serve per git subtree
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Create deploy marker
      run: |
        cd backend
        echo "Deployed at $(date -u +'%Y-%m-%d %H:%M:%S UTC') - Release ${{ needs.create-release-tag.outputs.new_tag }}" > .deploy-info
        cd ..
        git add backend/.deploy-info
        git commit -m "Deploy backend for release ${{ needs.create-release-tag.outputs.new_tag }}" || echo "No changes to commit"
    
    - name: Deploy Backend to deploy-backend branch
      run: |
        # Push del subtree backend su deploy-backend
        git subtree split --prefix backend -b temp-backend
        git push origin temp-backend:deploy-backend --force
        git branch -D temp-backend
    
    - name: Tag deploy-backend with release version
      run: |
        git push origin :refs/tags/${{ needs.create-release-tag.outputs.new_tag }}-backend || true
        git tag -a ${{ needs.create-release-tag.outputs.new_tag }}-backend -m "Backend release ${{ needs.create-release-tag.outputs.new_tag }}"
        git push origin ${{ needs.create-release-tag.outputs.new_tag }}-backend

  deploy-frontend:
    runs-on: ubuntu-latest
    needs: create-release-tag
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Build Frontend
      run: |
        cd frontend
        npm install
        npm run build
        cd ..
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Ensure LF line endings for text files only (not CRLF)
      run: |
        # Converti solo file di testo, NON i file binari come immagini
        find frontend/build -type f \( -name "*.html" -o -name "*.css" -o -name "*.js" -o -name "*.json" -o -name "*.xml" -o -name "*.txt" -o -name "*.md" \) -exec sed -i 's/\r$//' {} \;
    
    - name: Commit build files
      run: |
        git add -f frontend/build
        git commit -m "Build frontend for release ${{ needs.create-release-tag.outputs.new_tag }}" || echo "No changes to commit"
    
    - name: Deploy Frontend to deploy-frontend branch
      run: |
        # Push del subtree frontend/build su deploy-frontend
        git subtree split --prefix frontend/build -b temp-frontend
        git push origin temp-frontend:deploy-frontend --force
        git branch -D temp-frontend
    
    - name: Tag deploy-frontend with release version
      run: |
        git push origin :refs/tags/${{ needs.create-release-tag.outputs.new_tag }}-frontend || true
        git tag -a ${{ needs.create-release-tag.outputs.new_tag }}-frontend -m "Frontend release ${{ needs.create-release-tag.outputs.new_tag }}"
        git push origin ${{ needs.create-release-tag.outputs.new_tag }}-frontend

  create-github-release:
    runs-on: ubuntu-latest
    needs: [create-release-tag, deploy-backend, deploy-frontend]
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Necessario per leggere tutti i commits
    
    - name: Generate changelog
      id: changelog
      run: |
        # Trova il tag precedente
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 ${{ needs.create-release-tag.outputs.new_tag }}^ 2>/dev/null || echo "")
        
        # Genera il changelog con username GitHub
        if [ -z "$PREVIOUS_TAG" ]; then
          # Primo release: prendi tutti i commits
          COMMITS=$(git log --pretty=format:"%H|%s" --no-merges)
        else
          # Prendi i commits dall'ultimo tag
          COMMITS=$(git log ${PREVIOUS_TAG}..${{ needs.create-release-tag.outputs.new_tag }} --pretty=format:"%H|%s" --no-merges)
        fi
        
        # Costruisci il changelog con username GitHub usando l'API
        CHANGELOG=""
        while IFS='|' read -r HASH SUBJECT; do
          # Ottieni lo username GitHub dal commit usando l'API
          USERNAME=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/commits/${HASH}" | \
            jq -r '.author.login // .commit.author.name')
          
          # Aggiungi al changelog
          SHORT_HASH=${HASH:0:7}
          CHANGELOG="${CHANGELOG}- ${SUBJECT} (${SHORT_HASH}) - @${USERNAME}"$'\n'
        done <<< "$COMMITS"
        
        # Salva in una variabile di output (gestendo multiline)
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Conta i commits
        if [ -z "$PREVIOUS_TAG" ]; then
          COMMIT_COUNT=$(git rev-list --count HEAD --no-merges)
        else
          COMMIT_COUNT=$(git rev-list --count ${PREVIOUS_TAG}..${{ needs.create-release-tag.outputs.new_tag }} --no-merges)
        fi
        echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
    
    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.create-release-tag.outputs.new_tag }}
        release_name: Release ${{ needs.create-release-tag.outputs.new_tag }}
        body: |
          ## Release ${{ needs.create-release-tag.outputs.new_tag }}
          
          ### Deploy automatico completato
          - ‚úÖ Backend deployato su `deploy-backend`
          - ‚úÖ Frontend buildato e deployato su `deploy-frontend`
          
          ### Tag creati
          - `${{ needs.create-release-tag.outputs.new_tag }}` (main)
          - `${{ needs.create-release-tag.outputs.new_tag }}-backend`
          - `${{ needs.create-release-tag.outputs.new_tag }}-frontend`
          
          ---
          
          ### üìù Changelog (${{ steps.changelog.outputs.commit_count }} commits)
          
          ${{ steps.changelog.outputs.changelog }}
          
          ---
          
          _Deploy automatico by GitHub Actions_
        draft: false
        prerelease: false